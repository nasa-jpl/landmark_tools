##
#  \file   `visualize_corr.py`
#  \author Cecilia Mauceri
#  \brief  Visualize the displacement maps generated by landmark_comparison
#    
#  \copyright Copyright 2024 California Institute of Technology
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import matplotlib.pyplot as plt
plt.rcParams.update({'font.size': 14})

import numpy as np
from PIL import Image
import glob

def readBinaryImage(filename, width, height, dtype='float32', save_image=False):
    I = np.fromfile(filename, dtype=dtype)
    if(save_image):
        saveAsImage(I, filename.replace(".raw", ".tif"))
    return np.reshape(I, (height, width))

def saveAsImage(I, filename):
    Image.fromarray(I).save(filename)

def loadAllDisplacementMatrices(prefix, width, height, save_image=False):
    coor_files = glob.glob(prefix + "*.raw")
    displacement_maps = {}
    for filepath in coor_files:
        output_prefix = filepath.replace('.raw', '')
        
        if 'delta_x_' in filepath:
            key = 'dx'
        elif 'delta_y_' in filepath:
            key = 'dy' 
        elif 'delta_z_' in filepath:
            key = 'dz'
        elif 'corr_' in filepath:
            key = 'correlation'
        else:
            continue
 
        I = readBinaryImage(filepath, width, height, save_image=save_image)
        displacement_maps[key] = I
    return displacement_maps

def visualize_displacement(I, output_prefix, title_str, mask, limits=None, fig=None, ax=None, colorbar_label="Meters"):

    if limits is None:
        m = np.mean(I[~mask])
        sigma = np.std(I[~mask])
        limits = [m-4*sigma, m+4*sigma]

    if ax is None or fig is None:
        fig, ax = plt.subplots()
    
    cax = ax.matshow(I, cmap='coolwarm', vmin=limits[0], vmax=limits[1])
    ax.set_title(title_str)
    cbar = fig.colorbar(cax, extend='both')
    cbar.ax.set_ylabel(colorbar_label, rotation=270)

    # Axes
    [h, w] = I.shape
    ax.axis('equal')

    ax.set_ylabel("Pixels")
    
    ax.set_xlabel("Pixels")
    ax.xaxis.set_ticks_position('bottom') # Moves ticks to the bottom
    plt.xticks(rotation=45, ha='right') # Sets tick rotation
    
    # Save
    if output_prefix is not None:
        fig.savefig(output_prefix + '.png')

def visualize_correlation(correlation_map, output_prefix, title_str, fig=None, ax=None):

    if ax is None or fig is None:
        fig, ax = plt.subplots()
    
    cax = ax.matshow(correlation_map, cmap='Greens', vmin=0, vmax=1)
    ax.set_title(title_str)
    cbar = fig.colorbar(cax)
    cbar.ax.set_ylabel("Correlation", rotation=270)

    # Axes
    [h, w] = correlation_map.shape
    ax.axis('equal')

    ax.set_ylabel("Pixels")
    ax.set_xlabel("Pixels")
    ax.xaxis.set_ticks_position('bottom') # Moves ticks to the bottom
    plt.xticks(rotation=45, ha='right') # Sets tick rotation
    
    # Save
    if output_prefix is not None:
        fig.savefig(output_prefix + '_correlation.png')

def corr_histogram(I, output_prefix, title_str, mask, num_bins=50, fig=None, ax1=None, ax2=None, limits=None, ax2_title=None):

    if ax1 is None or fig is None:
        fig = plt.figure()
        ax1 = plt.subplot(1, 4, (1, 3))
        ax2 = plt.subplot(1, 4, 4)
    
    plt.axes(ax1)
    plt.hist(I[~mask], num_bins)
    plt.xlabel(title_str)
    plt.ylabel('Pixel Count')

    # Plot mean and 3-sigma
    m = np.mean(I[~mask])
    sigma = np.std(I[~mask])
    y0, y1 = plt.ylim()
    half_line = np.floor((y1-y0)/2)
    
    plt.vlines(m, y0, y1, colors='red')
    plt.text(m, y0+half_line, r'mean = {:.2f}'.format(m), rotation=90, ha='right')

    plt.vlines(m-3*sigma, y0, y1, colors='black')
    plt.text(m-3*sigma, y0+half_line, r'mean-3$\sigma$ = {:.2f}'.format(m-3*sigma), rotation=90, ha='right')

    plt.vlines(m+3*sigma, y0, y1, colors='black')
    plt.text(m+3*sigma, y0+half_line, r'mean+3$\sigma$ = {:.2f}'.format(m+3*sigma), rotation=90, ha='right')

    # Text summary
    plt.axes(ax2)
    if I[~mask].size == 0:
        minval = np.nan
        maxval = np.nan
    else:
        minval = min(I[~mask])
        maxval = max(I[~mask])
    text_summary = 'min : {:.2f}\nmax : {:.2f}\nmean : {:.2f}\nstd ('.format(minval, maxval, m) + \
        r'$\sigma$' +  \
        ') : {:.2f}'.format(sigma)
    if ax2_title is not None:
        text_summary = f"{ax2_title}\n" + text_summary
    plt.text(0, 0.5, text_summary)
    plt.axis('off')

    if (limits is not None) and all([not np.isnan(_v) for _v in limits]):
        ax1.set_xlim(limits)

    plt.tight_layout()

    if output_prefix is not None:
        plt.savefig(output_prefix + '-histogram.png')

def displayAllDisplacement(displacement_maps, filepath_prefix, on_grid=True):
    for key,I in displacement_maps.items():
        if key == 'dx':
            title = "Delta X"
        elif key == 'dy':
            title = "Delta Y"
        elif key == 'dz':
            title = "Delta Z"
        else:
            continue

        output_prefix = filepath_prefix + "_" + key
        mask = np.isnan(I)

        if on_grid:
            fig = plt.figure()
            ax = plt.subplot(1,9,(1,3))
        else:
            fig, ax = plt.subplots()
        visualize_displacement(I, output_prefix, title, mask, fig=fig, ax=ax)

        if on_grid:
            ax1= plt.subplot(1,9,(6,8))
            ax2= plt.subplot(1,9,9)
        else:
            fig = plt.figure()
            ax1 = plt.subplot(1, 4, (1, 3))
            ax2 = plt.subplot(1, 4, 4)
        corr_histogram(I, output_prefix, title, mask, fig=fig, ax1=ax1, ax2=ax2)

def displayCorrelation(correlation_map, filepath_prefix, on_grid=True):
    title = "Correlation"
    if on_grid:
            fig = plt.figure()
            ax = plt.subplot(1,9,(1,3))
    else:
        fig, ax = plt.subplots()
    visualize_correlation(correlation_map, filepath_prefix, title, fig=fig, ax=ax)

    if on_grid:
        ax1= plt.subplot(1,9,(6,8))
        ax2= plt.subplot(1,9,9)
    else:
        fig = plt.figure()
        ax1 = plt.subplot(1, 4, (1, 3))
        ax2 = plt.subplot(1, 4, 4)
    output_prefix = filepath_prefix + "_correlation"
    mask = np.isnan(correlation_map)
    corr_histogram(correlation_map, output_prefix, title, mask, limits=[0,1], fig=fig, ax1=ax1, ax2=ax2)

def displayAll(filepath_prefix, width, height, on_grid=True):
    displacement_maps = loadAllDisplacementMatrices(filepath_prefix, width, height, save_image=True)
    displayCorrelation(displacement_maps["correlation"], filepath_prefix, on_grid=on_grid)
    displayAllDisplacement(displacement_maps, filepath_prefix, on_grid=on_grid)

if __name__=='__main__':
    import argparse

    parser = argparse.ArgumentParser(
                    prog='VizualizeDEMCorrelation',
                    description='Visualize the output of landmark_comparison')
    parser.add_argument('prefix')
    parser.add_argument('width', type=int)
    parser.add_argument('height', type=int)

    args = parser.parse_args()

    displayAll(args.prefix, args.width, args.height, on_grid=False)
    print("All figures have been generated.")
