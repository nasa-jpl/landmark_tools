##
#  \file   `visualize_corr.py`
#  \author Cecilia Mauceri
#  \brief  Visualize the displacement maps generated by landmark_comparison
#    
#  \copyright Copyright 2024 California Institute of Technology
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import matplotlib.pyplot as plt
plt.rcParams.update({'font.size': 14})

import numpy as np
from PIL import Image

def readBinaryImage(filename, width, height, dtype='float32'):
    I = np.fromfile(filename, dtype=dtype)
    return np.reshape(I, (height, width))

def saveAsImage(I, filename):
    Image.fromarray(I).save(filename)

def visualize_corr(I, output_prefix, title_str, mask, limits=-1, fig=None, ax=None, ylabel="Meters"):

    if limits == -1:
        m = np.mean(I[~mask])
        sigma = np.std(I[~mask])
        limits = [m-4*sigma, m+4*sigma]

    if ax is None or fig is None:
        fig, ax = plt.subplots()
    
    cax = ax.matshow(I, cmap='coolwarm', vmin=limits[0], vmax=limits[1])
    ax.set_title(title_str)
    cbar = fig.colorbar(cax, extend='both')
    cbar.ax.set_ylabel(ylabel, rotation=270)

    # Axes
    [h, w] = I.shape
    ax.axis('equal')

    ax.set_ylabel("Pixels")
    
    ax.set_xlabel("Pixels")
    ax.xaxis.set_ticks_position('bottom') # Moves ticks to the bottom
    plt.xticks(rotation=45, ha='right') # Sets tick rotation
    
    # Save
    if output_prefix is not None:
        fig.savefig(output_prefix + '.png')


def corr_histogram(I, output_prefix, title_str, mask, num_bins=50, fig=None, ax1=None, ax2=None, limits=None, ax2_title=None):

    if ax1 is None or fig is None:
        fig = plt.figure()
        ax1 = plt.subplot(1, 4, (1, 3))
        ax2 = plt.subplot(1, 4, 4)
    
    plt.axes(ax1)
    plt.hist(I[~mask], num_bins)
    plt.xlabel(title_str)
    plt.ylabel('Pixel Count')

    # Plot mean and 3-sigma
    m = np.mean(I[~mask])
    sigma = np.std(I[~mask])
    y0, y1 = plt.ylim()
    half_line = np.floor((y1-y0)/2)
    
    plt.vlines(m, y0, y1, colors='red')
    plt.text(m, y0+half_line, r'mean = {:.2f}'.format(m), rotation=90, ha='right')

    plt.vlines(m-3*sigma, y0, y1, colors='black')
    plt.text(m-3*sigma, y0+half_line, r'mean-3$\sigma$ = {:.2f}'.format(m-3*sigma), rotation=90, ha='right')

    plt.vlines(m+3*sigma, y0, y1, colors='black')
    plt.text(m+3*sigma, y0+half_line, r'mean+3$\sigma$ = {:.2f}'.format(m+3*sigma), rotation=90, ha='right')

    # Text summary
    plt.axes(ax2)
    if I[~mask].size == 0:
        minval = np.nan
        maxval = np.nan
    else:
        minval = min(I[~mask])
        maxval = max(I[~mask])
    text_summary = 'min : {:.2f}\nmax : {:.2f}\nmean : {:.2f}\nstd ('.format(minval, maxval, m) + \
        r'$\sigma$' +  \
        ') : {:.2f}'.format(sigma)
    if ax2_title is not None:
        text_summary = f"{ax2_title}\n" + text_summary
    plt.text(0, 0.5, text_summary)
    plt.axis('off')

    if (limits is not None) and all([not np.isnan(_v) for _v in limits]):
        ax1.set_xlim(limits)

    plt.tight_layout()

    if output_prefix is not None:
        plt.savefig(output_prefix + '-histogram.png')

def displayAll(filepath_prefix, width, height, output_prefix, mask_value=None):
    for c in ['x', 'y', 'z']:
        fig = plt.figure()
        filepath = "{}_delta_{}_{}by{}.raw".format(filepath_prefix, c, width, height)
        
        I = readBinaryImage(filepath, width, height)
        if(mask_value is None):
            mask = np.isnan(I)
        else:
            mask = I==mask_value

        ax = plt.subplot(1,9,(1,3))
        visualize_corr(I, None, "Delta {}".format(c), mask, fig=fig, ax=ax)

        ax1= plt.subplot(1,9,(6,8))
        ax2= plt.subplot(1,9,9)
        corr_histogram(I, "{}_{}".format(output_prefix, c), "Delta {}".format(c), mask, fig=fig, ax1=ax1, ax2=ax2)

if __name__=='__main__':
    import argparse
    import glob

    parser = argparse.ArgumentParser(
                    prog='VizualizeDEMCorrelation',
                    description='Visualize the output of landmark_comparison')
    parser.add_argument('prefix')
    parser.add_argument('width', type=int)
    parser.add_argument('height', type=int)

    args = parser.parse_args()

    coor_files = glob.glob(args.prefix + "*.raw")
    for filepath in coor_files:
        output_prefix = filepath.replace('.raw', '')
        
        if 'delta_x_' in filepath:
            title = "Delta X";
            limit = [-50, 50];
        elif 'delta_y_' in filepath:
            title = "Delta Y";
            limit = [-50, 50];  
        elif 'delta_z_' in filepath:
            title = "Delta Z";
            limit = [-20, 20];
        else:
            continue
 
        I = readBinaryImage(filepath, args.width, args.height)
        saveAsImage(I, output_prefix+".tif")

        mask = np.isnan(I)
        visualize_corr(I, output_prefix, title, mask, limit)
        corr_histogram(I, output_prefix, title, mask)

    print("All figures have been generated.")
